<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Audio Reactive Spheres</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            display: flex;  
        }
        #thresholds {
            width: 200px;  /* Adjust this as needed */
            height: 100%;
            /* overflow: auto; */
        }

        #container {
            height: 500px;
            flex-grow: 1;
        }
    </style>
    <script src="js/threejs.org_build_three.js"></script>
    <script src="js/cdn.jsdelivr.net_npm_@tonejs_midi.js"></script>
    <script src="js/cdn.jsdelivr.net_npm_tone.js"></script>



</head>
<body>
  
    <div id="thresholds">
     music:  <input type="file" id="audioInput" multiple  accept="audio/*, .midi, .mid">
    video: <input type="file" id="videoInput" accept="video/*" multiple>

    <!-- image: <input type="file" id="folderInput" webkitdirectory directory multiple /> -->

    <video id="videoElement" style="display:none;" autoplay muted></video>
    
        <div id="master-control">
            <span>Master Volume Threshold: </span>
            <input type="range" id="master" min="-100" max="355" value="150">
            <br>
        </div>    

    </div>
    <button id="startButton">Start</button>
    <div id="container"></div>
    <div id="advancedControls">
        <!-- Hue increase <input id="hueincrease" value="0">
        X Rotation <input id="xrotation" value="0.001">
        Y Rotation <input id="yrotation" value="0.0001">
        Bands <input id="numBands" value="48"> -->
    </div>

<script>
        let hueoffset = 20;
        let hueOffsetSpeed = 0;
        let startingVolumeThreshold = 5;
        let thresholds = Array(22).fill(startingVolumeThreshold);
        let freezeFrameEffectActive = true;
        let X_ROTATION_SPEED = 0.0001;
        let Y_ROTATION_SPEED = 0.0005;
        let ACTIVE_GEOMETRIES_LIMIT = 25;
        let FORCE_EQUILATERAL = false;
        let innerTriangleActive = false;
        let innerTriangleOffset = 0.005;
        let merkabaMode = false;

        let REFRESH_SPEED = 3;
        let saturation = 100;
        let brightness = 50; 
        let volumemagnification = 1.4; 

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 100);
        camera.position.z = 2;
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio * 2); // x times the normal resolution

        renderer.shadowMap.enabled = true;
        const pointLight = new THREE.PointLight(0xffffff, 1, 100);
        pointLight.position.set(1, 1, 1);  // x, y, z
        scene.add(pointLight);
        pointLight.castShadow = true;


        let container = document.getElementById('container');
        renderer.setSize(container.clientWidth, container.clientHeight);
        container.appendChild(renderer.domElement);

        var analyser;

        let numBands = 48;

        let holographicFanMode = false;

        let baseFrequency = 20; // Start from 20 Hz
        let maxFrequency = 20000; // Up to 20 kHz

        let dodecahedronMaterial; 

                // Now calculate the ratio between each band in a logarithmic scale
        let ratio = Math.pow(maxFrequency / baseFrequency, 1.0 / (numBands - 1));
       
       
        let points = [];
        let lines = [];
        let geometries = [];
        let lastPoints = [];

        //TODO: this function doesn't preoperly work when run repeat times (i.e. the points are evenly distributed over the surface of the sphere)
        function initBands(){

        // Now we can get the frequency for each band
        for (let i = 0; i < numBands; i++) {
        let bandFrequency = baseFrequency * Math.pow(ratio, i);
        console.log('Band ' + i + ' frequency: ' + bandFrequency + ' Hz');
        }

        

        let goldenRatio = (1 + Math.sqrt(5)) / 2;
        let angleIncrement = Math.PI * 2 * goldenRatio;


            for (let i = 0; i < numBands; i++) {
                let v = i / numBands;
                let phi = v * Math.PI;
                let theta = angleIncrement * i;

                let x = Math.sin(phi) * Math.cos(theta);
                let y = Math.sin(phi) * Math.sin(theta);
                let z = Math.cos(phi);

                x = isNaN(x) ? 0 : x;
                y = isNaN(y) ? 0 : y;
                z = isNaN(z) ? 0 : z;

                let point = new THREE.Points(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0)]), new THREE.PointsMaterial({color: 0xffffff, size: 0.01}));
                point.position.set(x, y, z);
                points.push(point);
                // scene.add(point);


            }


        }

        initBands();


        function animate() {
            requestAnimationFrame(animate);

            // untoggle if to make fully deterministic
            hueoffset += hueOffsetSpeed;

            if(hueoffset > 360) {
                hueoffset -= 360;
            }

            let data = new Uint8Array(analyser.frequencyBinCount);
            analyser.getByteFrequencyData(data);

            let bandSize = Math.floor(data.length / numBands);

            clearNoteSpheres();

            let bandWidth = audioContext.sampleRate / analyser.frequencyBinCount; // Adjust as necessary based on how you set up the Web Audio API.

            for (let i = 0; i < numBands; i++) {
                let band = data.slice(i * bandSize, (i + 1) * bandSize);
                let note = detectNoteFromBand(band, bandWidth);

                if (note) {
                    console.log("note detected");
                    let noteSphere = createNoteSphere(note);
                    noteSphere.position.copy(points[i].position);  // Set the note sphere's position to the point's position
                    noteSphere.userData.type = 'noteSphere';  // Tagging the sphere so that we can easily remove it later
                    noteSphere.scale.set(0.1, 0.1, 0.1);  // Scale down the sphere to make it smaller
                    scene.add(noteSphere);
                    console.log("Added note sphere:", noteSphere);

                }
                let volume = getAverageVolume(band);
                
            }
            for (let i = 0; i < numBands; i++) {
                // TODO: this doesn't seem to be properly using the band frequency

                let band = data.slice(i * bandSize, (i + 1) * bandSize);
                let volume = getAverageVolume(band);
                let volumeDisplay = document.getElementById('volume' + i);
                volumeDisplay.textContent = 'v: ' + volume.toFixed(2) + ' / ' + thresholds[i];


                if (volume >= thresholds[i]) {


                    let hue = (volume * volumemagnification) + hueoffset;
                    // let hue = 10;
                    if (hue > 360) hue -= 360;
                    let color = new THREE.Color('hsl(' + hue + ', ' + saturation + '%, ' + brightness  + '%)');
                   
                    // console.log(band);


                    // let detectedNote = detectNote(band);  // Implement detectNote() based on your frequency to note logic
                    // if (detectedNote) {

                    // }

                    if(points[i]) points[i].material.color = color;

                    volumeDisplay.style.color = '#00ff00'; // green
                    if (lastPoints.length >= 3) {


                        var geometry = createTriangleGeometry(lastPoints[0], lastPoints[1], lastPoints[2]);
                        var material; 
                        if(videoElementActive) {
                             var texture = getVideoFrameTexture();
                             var opacitylevel =  (12 / volume ) + .2;
                             // TODO: hits infinity too often
                            //  console.log(opacitylevel);
                             material = new THREE.MeshBasicMaterial({map:texture, opacity: opacitylevel, transparent: true, side: THREE.DoubleSide});
                             material.needsUpdate = true;
                        }
                        else if (imageElementActive) {

                            var texture = getNextImageTexture();
                             material = new THREE.MeshBasicMaterial({map:texture, opacity: 0.6, transparent: true, side: THREE.DoubleSide});
                             material.needsUpdate = true;

                        } else  {

                            material = new THREE.MeshBasicMaterial({color: color, opacity: 0.6, transparent: true, side: THREE.DoubleSide});

                        }

                        var triangle = new THREE.Mesh(geometry, material);

                
                        triangle.castShadow = true;    // to cast shadows
                        triangle.receiveShadow = true; // to receive shadows

                        // const tetra = new THREE.TetrahedronGeometry(.5);


                        scene.add(triangle); 
                        if (innerTriangleActive)
                        {
                            var innerGeometry = createInnerTriangleGeometry(lastPoints[0], lastPoints[1], lastPoints[2]);
                            var innerMaterial = new THREE.MeshBasicMaterial({color: "black", opacity: 0.5, transparent: false, side: THREE.DoubleSide});
                            var innerTriangle = new THREE.Mesh(innerGeometry, innerMaterial);
                            scene.add(innerTriangle); 

                        }

                        if (geometries.length > ACTIVE_GEOMETRIES_LIMIT) {

                                geometries[0].geometry.geometry.dispose();
                                geometries[0].geometry.material.dispose();
                                scene.remove(geometries[0].geometry);
                                geometries.shift();

                        }

                        geometries.push({geometry: triangle, age: 0});
                        if (innerTriangleActive)
                        {
                            geometries.push({geometry: innerTriangle, age: 0});

                        }

                        lastPoints.shift();
                    }

                    lastPoints.push(points[i].position.clone());
                } else {
                    volumeDisplay.style.color = '#ff0000'; // red
                }
            }

            for (let i = geometries.length - 1; i >= 0; i--) {
                geometries[i].age++;
                if (geometries[i].age > 20) {
                    geometries[i].geometry.material.opacity -= 0.01;
                    if (geometries[i].geometry.material.opacity <= 0) {
                        scene.remove(geometries[i].geometry);
                        geometries.splice(i, 1);
                    }
                }
            }

            scene.rotation.x += X_ROTATION_SPEED; 
            scene.rotation.y += Y_ROTATION_SPEED;

            renderer.render(scene, camera);
        }

        let audioContext;
        let startButton = document.getElementById('startButton');
        startButton.addEventListener('click', function() {
            startButton.parentElement.removeChild(startButton);

            navigator.mediaDevices.getUserMedia({ audio: true, video: false }).then(function(stream) {
                audioContext = new AudioContext();
                let source = audioContext.createMediaStreamSource(stream);
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 2048 * 2 * 2;
                source.connect(analyser);
                animate();
            });
        });

        let masterInput = document.getElementById('master');
        masterInput.value = startingVolumeThreshold;

        let thresholdsDiv = document.getElementById('thresholds');
        let startingVolumeThresholds = new Array(numBands).fill(startingVolumeThreshold);

        for(let i = 0; i < numBands; i++){
            let highEnd = 200; // maximum volume threshold for lowest frequency band
            let lowEnd = 10;   // minimum volume threshold for highest frequency band
            let range = highEnd - lowEnd;

            let input = document.createElement('input');
            input.type = 'range';
            input.min = '0';
            input.max = '255';
            input.value = startingVolumeThreshold;
            startingVolumeThresholds[i] = startingVolumeThreshold;
            thresholds[i] =  startingVolumeThreshold;

            // input.value = highEnd - Math.floor((i/numBands) * range);
            // startingVolumeThresholds[i] = highEnd - Math.floor((i/numBands) * range);
            input.id = 'threshold' + i;
            input.oninput = function(){
                thresholds[i] = this.value;  // Set the threshold for specific band
                // Add this line to update the display text when the threshold changesf
                // document.getElementById('volume' + i).textContent = 'v: ' + startingVolumeThresholds[i] + ' 0 / ' + startingVolumeThresholds[i];
                document.getElementById('volume' + i).textContent = 'v: 0 / ' + thresholds[i];

            };

            let volumeDisplay = document.createElement('span');
            volumeDisplay.id = 'volume' + i;
            volumeDisplay.style.color = 'white';
            volumeDisplay.textContent = "v: ";

            thresholdsDiv.appendChild(document.createTextNode('Band ' + i + ': '));
            thresholdsDiv.appendChild(input);
            thresholdsDiv.appendChild(volumeDisplay);
            thresholdsDiv.appendChild(document.createElement('br'));
            document.getElementById('volume' + i).textContent = 'v: 0 / ' + thresholds[i];
            document.getElementById('volume' + i).style = 'color:black';

        }

        let master = document.getElementById('master');
        let lastMasterValue = startingVolumeThreshold;
        master.oninput = function() {
            let masterValue = this.value;
            let delta = masterValue - lastMasterValue;
            // startingVolumeThresholds = startingVolumeThresholds.map(() => masterValue);  // Set all thresholds to the master's value

            for (let i = 0; i < numBands; i++) {
                let input = document.getElementById('threshold' + i);
                thresholds[i] =  parseInt(input.value) + delta;
                input.value = parseInt(input.value) + delta;
                document.getElementById('volume' + i).textContent = 'v: 0 / ' + input.value;
            }

            lastMasterValue = masterValue;
        };

        const audioQueue = [];
        let audioSource;  // Keep track of the current audio source

    document.getElementById('audioInput').addEventListener('change', async function(event) {

        audioContext = new AudioContext();
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 2048 * 2 * 2;

        // Populate the audioQueue with the selected files
        audioQueue.length = 0;  // Clear the queue
        for (let file of event.target.files) {
            console.log(file);
            audioQueue.push(file);
        }

        playNext();

    });




    // function playSound(buffer) {
    //     let source = audioContext.createBufferSource(); 
    //     source.buffer = buffer;
    //     source.connect(analyser); // Connect source to the analyser
    //     source.connect(audioContext.destination); // Connect source to the speakers
    //     source.start(0);
    // }

// SECTION: video

        // for video render
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        let videoElementActive = false;
        let imageElementActive = false;

    function captureFrame(videoElement) {
        ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
        return ctx.getImageData(0, 0, canvas.width, canvas.height);

    }

    function getVideoFrameTexture() {

        // if(freezeFrameEffectActive)
        //     videoElement.pause();


        ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
        let texture = new THREE.Texture(canvas);
        texture.needsUpdate = true;

        if (dodecahedronMaterial) {
            dodecahedronMaterial.map = texture;
            dodecahedronMaterial.needsUpdate = true;
        }

        videoElement.playbackRate = 1.0;  // Ensure normal playback speed
        videoElement.play();

        if(freezeFrameEffectActive)
             return texture;
    }

    // const allVideoQueues;s

    const activeVideoQueue = [];
    const originalVideos = [];

    const videoElement = document.getElementById('videoElement');

document.getElementById('videoInput').addEventListener('change', function(event) {

    // if(activeVideoQueue.length > 0)
    //      allVideoQueues.push("video1", )

    activeVideoQueue.length = 0;
    originalVideos.length = 0;

    // Convert FileList to Array and add to activeVideoQueue
    for (let file of event.target.files) {
        const url = URL.createObjectURL(file);
        console.log(url);
        activeVideoQueue.push(url);
        originalVideos.push(url);

    }

    // Play the first video
    if (activeVideoQueue.length > 0) {
        videoElement.src = activeVideoQueue.shift();
        videoElement.play();
        videoElementActive = true;

        if (holographicFanMode) {
            const dodecahedronRadius = 0.15;
            const dodecahedronGeometry = new THREE.DodecahedronGeometry(dodecahedronRadius);

            // Get the video frame texture
            let texture = getVideoFrameTexture();

            // Create a material with that texture
            dodecahedronMaterial = new THREE.MeshBasicMaterial({ map: texture });

            // Create the mesh and add it to the scene
            const dodecahedron = new THREE.Mesh(dodecahedronGeometry, dodecahedronMaterial);
            scene.add(dodecahedron);
        }
    }
    else {
        console.error('Video format not supported');
    }
});

videoElement.addEventListener('ended', function() {
    if (activeVideoQueue.length === 0) {
        // Repopulate activeVideoQueue with original video URLs
        activeVideoQueue.push(...originalVideos);
    }

    console.log("nextvideo");
    if (activeVideoQueue.length > 0) {
        videoElement.src = activeVideoQueue.shift();
        videoElement.playbackRate = 1.0;  // Ensure normal playback speed
        videoElement.play();
    } else {
        console.log("All videos have been played!");
    }
});

    let loadedImages = [];

    var dodecahedron; 
    if(holographicFanMode) {
        const dodecahedronRadius = 0.1;  // Adjust as needed
        const dodecahedronGeometry = new THREE.DodecahedronGeometry(dodecahedronRadius);
        const dodecahedronMaterial = new THREE.MeshBasicMaterial({ color: "blue" });  // White color
        dodecahedron = new THREE.Mesh(dodecahedronGeometry, dodecahedronMaterial);
        dodecahedron.position.set(0, 0, 0);
        scene.add(dodecahedron);

    }

    const NOTES_ARRAY = [
    {note: 'C0', frequency: 16.35},
    {note: 'C#0/Db0', frequency: 17.32},
    {note: 'D0', frequency: 18.35},
    {note: 'D#0/Eb0', frequency: 19.45},
    {note: 'E0', frequency: 20.60},
    {note: 'F0', frequency: 21.83},
    {note: 'F#0/Gb0', frequency: 23.12},
    {note: 'G0', frequency: 24.50},
    {note: 'G#0/Ab0', frequency: 25.96},
    {note: 'A0', frequency: 27.50},
    {note: 'A#0/Bb0', frequency: 29.14},
    {note: 'B0', frequency: 30.87},

    {note: 'C8', frequency: 4186.01},
    {note: 'C#8/Db8', frequency: 4434.92},
    {note: 'D8', frequency: 4698.63},
    {note: 'D#8/Eb8', frequency: 4978.03},
    {note: 'E8', frequency: 5274.04},
    {note: 'F8', frequency: 5587.65},
    {note: 'F#8/Gb8', frequency: 5919.91},
    {note: 'G8', frequency: 6271.93},
    {note: 'G#8/Ab8', frequency: 6644.88},
    {note: 'A8', frequency: 7040.00},
    {note: 'A#8/Bb8', frequency: 7458.62},
    {note: 'B8', frequency: 7902.13}
];

    const NOTES_NONARRAY = {
    A0: 27.50,
    Bb0: 29.14,
    B0: 30.87,
    C1: 32.70,
    Db1: 34.65,
    D1: 36.71,
    Eb1: 38.89,
    E1: 41.20,
    F1: 43.65,
    Gb1: 46.25,
    G1: 49.00,
    Ab1: 51.91,
    A1: 55.00,
    Bb1: 58.27,
    B1: 61.74,
    C2: 65.41,
    Db2: 69.30,
    D2: 73.42,
    Eb2: 77.78,
    E2: 82.41,
    F2: 87.31,
    Gb2: 92.50,
    G2: 98.00,
    Ab2: 103.83,
    A2: 110.00,
    Bb2: 116.54,
    B2: 123.47,
    C3: 130.81,
    Db3: 138.59,
    D3: 146.83,
    Eb3: 155.56,
    E3: 164.81,
    F3: 174.61,
    Gb3: 185.00,
    G3: 196.00,
    Ab3: 207.65,
    A3: 220.00,
    Bb3: 233.08,
    B3: 246.94,
    C4: 261.63,
    Db4: 277.18,
    D4: 293.66,
    Eb4: 311.13,
    E4: 329.63,
    F4: 349.23,
    Gb4: 369.99,
    G4: 392.00,
    Ab4: 415.30,
    A4: 440.00,  // Standard tuning reference pitch
    Bb4: 466.16,
    B4: 493.88,
    C5: 523.25,
    Db5: 554.37,
    D5: 587.33,
    Eb5: 622.25,
    E5: 659.26,
    F5: 698.46,
    Gb5: 739.99,
    G5: 783.99,
    Ab5: 830.61,
    A5: 880.00,
    Bb5: 932.33,
    B5: 987.77,
    C6: 1046.50,
    Db6: 1108.73,
    D6: 1174.66,
    Eb6: 1244.51,
    E6: 1318.51,
    F6: 1396.91,
    Gb6: 1479.98,
    G6: 1567.98,
    Ab6: 1661.22,
    A6: 1760.00,
    Bb6: 1864.66,
    B6: 1975.53,
    C7: 2093.00,
    Db7: 2217.46,
    D7: 2349.32,
    Eb7: 2489.02,
    E7: 2637.02,
    F7: 2793.83,
    Gb7: 2959.96,
    G7: 3135.96,
    Ab7: 3322.44,
    A7: 3520.00,
    Bb7: 3729.31,
    B7: 3951.07,
    C8: 4186.01
};


const NOTES = Object.entries(NOTES_NONARRAY).map(([note, frequency]) => ({note, frequency}));

    function frequencyToMIDINoteNumber(frequency) {
    const referenceFrequency = 440; // A4
    return Math.round(69 + 12 * Math.log2(frequency / referenceFrequency));
}

function midiNoteNumberToNoteName(midiNoteNumber) {
    const noteNames = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
    const noteName = noteNames[midiNoteNumber % 12];
    const octave = Math.floor(midiNoteNumber / 12) - 1;
    return noteName + octave;
}

function getPeakFrequencies(dataArray, threshold) {
    let peaks = [];
    for (let i = 1; i < dataArray.length - 1; i++) {
        if (dataArray[i] > threshold && dataArray[i] > dataArray[i-1] && dataArray[i] > dataArray[i+1]) {
            peaks.push(i);
        }
    }
    return peaks;
}

function labelDetectedTones(dataArray, threshold) {
    const peakIndices = getPeakFrequencies(dataArray, threshold);
    return peakIndices.map(index => {
        const frequency = index * (audioContext.sampleRate / 2) / dataArray.length; // Convert index to frequency
        const midiNoteNumber = frequencyToMIDINoteNumber(frequency);
        return midiNoteNumberToNoteName(midiNoteNumber);
    });
}

function generateNoteTexture(note) {
    const canvas = document.createElement('canvas');
    canvas.width = 256;
    canvas.height = 256;
    const context = canvas.getContext('2d');

    // Fill the canvas with a color (e.g., white)
    context.fillStyle = 'white';
    context.fillRect(0, 0, canvas.width, canvas.height);

    // Set the font and draw the note in the center
    context.font = '50px Arial';
    context.fillStyle = 'black';
    context.textAlign = 'center';
    context.textBaseline = 'middle';
    console.log(note);
    context.fillText(note.note, canvas.width / 2, canvas.height / 2);

    // Return a Three.js texture
    const texture = new THREE.CanvasTexture(canvas);
    return texture;
}

function createNoteSphere(note) {
    const radius = 1;  // you can adjust this as needed

    // Create the sphere geometry
    const geometry = new THREE.SphereGeometry(radius, 32, 32);

    // Use the note texture for the material
    const material = new THREE.MeshBasicMaterial({ map: generateNoteTexture(note) });

    // Create and return the sphere mesh
    return new THREE.Mesh(geometry, material);
}

function detectNote(band) {
    // TODO: Placeholder for actual note detection
    const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    return notes[band % notes.length];
}

function clearNoteSpheres() {
    for (let i = scene.children.length - 1; i >= 0; i--) {
        let child = scene.children[i];
        if (child.userData && child.userData.type === 'noteSphere') {
            scene.remove(child);
        }
    }
}

function getPeakIndex(data) {
    const THRESHOLD = 40; // Adjust as needed.
    let peakIndex = null;
    let maxVal = -Infinity;

    for (let i = 1; i < data.length - 1; i++) {
        if (data[i] > THRESHOLD && data[i] > maxVal && data[i] > data[i-1] && data[i] > data[i+1]) {
            peakIndex = i;
            maxVal = data[i];
        }
    }

    return peakIndex;
}

function detectNoteFromBand(band, bandWidth) {
    const peakIndex = getPeakIndex(band);
    if (peakIndex === null) return null;

    const freq = peakIndex * bandWidth;
    let closestNote = NOTES[0];
    let smallestDifference = Math.abs(NOTES[0].frequency - freq);

    for (let i = 1; i < NOTES.length; i++) {
        const difference = Math.abs(NOTES[i].frequency - freq);
        if (difference < smallestDifference) {
            closestNote = NOTES[i];
            smallestDifference = difference;
        }
    }

    return closestNote;
}

    
    </script>
<script src="js/audio_controller.js"></script>
<script src="js/sonic_geometries.js"></script>
<script src="js/message_controller.js"></script>
</body>
</html>
