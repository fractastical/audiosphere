<!DOCTYPE html>
<script src="https://threejs.org/build/three.js"></script>
<body>
<button id="startButton">Start</button>
<script>
let scene, camera, renderer, audioContext, analyser;
let xPos = 0;

function setupThreeJS() {
    // Set up Three.js scene, camera, and renderer.
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    // Position the camera.
    camera.position.z = 5;
}

function setupAudio() {
    // Set up the audio context and analyser.
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
    analyser = audioContext.createAnalyser();

    // Connect the microphone stream to the analyzer and the analyzer to the destination.
    navigator.mediaDevices.getUserMedia({ audio: true, video: false })
        .then(function(stream) {
            // Create a gain node to prevent audio feedback.
            let gainNode = audioContext.createGain();
            gainNode.gain.value = 0;  // Mute the audio.

            let source = audioContext.createMediaStreamSource(stream);
            source.connect(analyser);
            analyser.connect(gainNode);
            gainNode.connect(audioContext.destination);

            // Start rendering the visualization.
            animate();
        })
        .catch(function(err) {
            console.log('The following error occured: ' + err);
        });
}

let prevAverage = 0;

function animate() {
    requestAnimationFrame(animate);

    // Get the average volume of the sound.
    let data = new Uint8Array(analyser.frequencyBinCount);
    analyser.getByteFrequencyData(data);
    let average = getAverageVolume(data);

    // Calculate the change in volume.
    let delta = Math.abs(prevAverage - average);

    // If the volume change exceeds a certain threshold, create a new sphere.
    if (delta > 5) {
        // Limit the maximum average volume used for the geometry and color calculations.
        let limitedAverage = Math.min(average, 100);

        // Get the color based on the volume. This is a simplistic mapping, but you could use a more sophisticated approach based on Goethe's color theory.
        let color = new THREE.Color('hsl(' + limitedAverage + ', 100%, 50%)');
        console.log(average);

        let geometry = new THREE.SphereGeometry(limitedAverage / 100, limitedAverage, limitedAverage);
        let material = new THREE.MeshBasicMaterial({color: color});
        let sphere = new THREE.Mesh(geometry, material);
        sphere.castShadow = true;  // Enable shadows for this sphere.

        sphere.position.x = xPos;
        xPos += 1;  // Move the position to the right for the next sphere.
        scene.add(sphere);

        // Move the camera along with the sphere generation.
        camera.position.x = xPos;
    }

    // Store the current average volume for the next frame.
    prevAverage = average;

    // Render the scene.
    renderer.render(scene, camera);
}


function getAverageVolume(array) {
    let values = 0;
    let average;
    let length = array.length;

    // Get all the frequency amplitudes.
    for (let i = 0; i < length; i++) {
        values += array[i];
    }

    average = values / length;
    return Math.round(average);
}

document.getElementById('startButton').addEventListener('click', function() {
    setupThreeJS();
    setupAudio();
});
</script>
</body>
</html>
