<!DOCTYPE html>
<script src="https://threejs.org/build/three.js"></script>
<body>
<button id="startButton">Start</button>
<script>
let scene, camera, renderer, audioContext, analyser;
let xPos = 0;

function setupThreeJS() {
    // Set up Three.js scene, camera, and renderer.
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    // Position the camera.
    camera.position.z = 5;
}

function setupAudio() {
    // Set up the audio context and analyser.
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
    analyser = audioContext.createAnalyser();

    // Connect the microphone stream to the analyzer and the analyzer to the destination.
    navigator.mediaDevices.getUserMedia({ audio: true, video: false })
        .then(function(stream) {
            // Create a gain node to prevent audio feedback.
            let gainNode = audioContext.createGain();
            gainNode.gain.value = 0;  // Mute the audio.

            let source = audioContext.createMediaStreamSource(stream);
            source.connect(analyser);
            analyser.connect(gainNode);
            gainNode.connect(audioContext.destination);

            // Start rendering the visualization.
            animate();
        })
        .catch(function(err) {
            console.log('The following error occured: ' + err);
        });
}

let prevLowerAverage = 0;
let prevUpperAverage = 0;

function animate() {
    requestAnimationFrame(animate);

    // Get the frequency data.
    let data = new Uint8Array(analyser.frequencyBinCount);
    analyser.getByteFrequencyData(data);

    // Split the frequency data into lower and upper halves.
    let half = data.length / 2;
    let lowerData = data.slice(0, half);
    let upperData = data.slice(half);

    // Calculate the average volume in the lower and upper bands.
    let lowerAverage = getAverageVolume(lowerData);
    let upperAverage = getAverageVolume(upperData);

    // Calculate the change in volume.
    let lowerDelta = Math.abs(prevLowerAverage - lowerAverage);
    let upperDelta = Math.abs(prevUpperAverage - upperAverage);

    // If the volume change in the lower band exceeds a certain threshold, create a small red sphere.
    if (lowerDelta > 5) {
        let geometry = new THREE.SphereGeometry(0.5, 32, 32);
        let material = new THREE.MeshBasicMaterial({color: 'red'});
        let sphere = new THREE.Mesh(geometry, material);
        sphere.castShadow = true;

        sphere.position.x = xPos;
        xPos += 2;
        scene.add(sphere);

        camera.position.x = xPos;
    }

    // If the volume change in the upper band exceeds a certain threshold, create a large blue sphere.
    if (upperDelta > 5) {
        let geometry = new THREE.SphereGeometry(1, 32, 32);
        let material = new THREE.MeshBasicMaterial({color: 'blue'});
        let sphere = new THREE.Mesh(geometry, material);
        sphere.castShadow = true;

        sphere.position.x = xPos;
        xPos += 2;
        scene.add(sphere);

        camera.position.x = xPos;
    }

    // Store the current average volumes for the next frame.
    prevLowerAverage = lowerAverage;
    prevUpperAverage = upperAverage;

    // Render the scene.
    renderer.render(scene, camera);
}

// let prevAverage = 0;

// function animate() {
//     requestAnimationFrame(animate);

//     // Get the average volume of the sound.
//     let data = new Uint8Array(analyser.frequencyBinCount);
//     analyser.getByteFrequencyData(data);
//     let average = getAverageVolume(data);

//     // Calculate the change in volume.
//     let delta = Math.abs(prevAverage - average);

//     // If the volume change exceeds a certain threshold, create a new sphere.
//     if (delta > 5) {
//         // Limit the maximum average volume used for the geometry and color calculations.
//         let limitedAverage = Math.min(average, 100);

//         // Get the color based on the volume. This is a simplistic mapping, but you could use a more sophisticated approach based on Goethe's color theory.
//         let color = new THREE.Color('hsl(' + limitedAverage + ', 100%, 50%)');
//         console.log(average);

//         let geometry = new THREE.SphereGeometry(limitedAverage / 100, limitedAverage, limitedAverage);
//         let material = new THREE.MeshBasicMaterial({color: color});
//         let sphere = new THREE.Mesh(geometry, material);
//         sphere.castShadow = true;  // Enable shadows for this sphere.

//         sphere.position.x = xPos;
//         xPos += 1;  // Move the position to the right for the next sphere.
//         scene.add(sphere);

//         // Move the camera along with the sphere generation.
//         camera.position.x = xPos;
//     }

//     // Store the current average volume for the next frame.
//     prevAverage = average;

//     // Render the scene.
//     renderer.render(scene, camera);
// }


function getAverageVolume(array) {
    let values = 0;
    let average;
    let length = array.length;

    // Get all the frequency amplitudes.
    for (let i = 0; i < length; i++) {
        values += array[i];
    }

    average = values / length;
    return Math.round(average);
}

document.getElementById('startButton').addEventListener('click', function() {
    setupThreeJS();
    setupAudio();
});
</script>
</body>
</html>
