<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Audio Reactive Spheres</title>
    <style>

        
        body {
            margin: 0;
            overflow: hidden;
            display: flex;  
            background-color: black;
        }
        #thresholds {
            width: 200px;  /* Adjust this as needed */
            height: 100%;
            /* align:left; */
            background-color: white;
            overflow-y: scroll;
        
        }

        #videoList {
            max-height: 400px;
            overflow-y: auto;
            padding: 10px;
            color: white;
        }

            /*             border: 1px solid #ccc;
; */

        #container {
            margin-top:50px;
            height: 500px;
            flex-grow: 1;
        }

        /* body {
  font-family: 'Arial', sans-serif;
  background-color: #222;
  color: #eee;
  padding: 20px;
} */

/* #app {
  max-width: 200px;
  margin: 0 auto;
}
 */
.file-input-group,
#master-control {
  margin-bottom: 15px;
}

label {
  display: block;
  margin-bottom: 5px;
}

input[type="file"] {
  width: 85%;
  padding: 10px;
  background-color: #444;
  color: #eee;
  border: none;
  border-radius: 5px;
}

input[type="range"] {
  width: calc(100% - 10px);
  margin: 5px;
}

button {
  background-color: #4CAF50; /* Green */
  border: none;
  color: white;
  padding: 5px 16px;
  text-align: center;
  text-decoration: none;
  display: inline-block;
  font-size: 16px;
  margin: 4px 2px;
  transition-duration: 0.4s;
  cursor: pointer;
  border-radius: 5px;
}

button:hover {
  background-color: white;
  color: black;
}

.hidden {
  display: none;
}

    </style>
    <script src="js/threejs.org_build_three.js"></script>
    <script src="js/cdn.jsdelivr.net_npm_@tonejs_midi.js"></script>
    <script src="js/cdn.jsdelivr.net_npm_tone.js"></script>

    <script>

let currentText = '';
let currentIndex = 0;
let intervalHandle = null;
let displaySpeed = 200; // Speed in milliseconds
const textCanvas = document.createElement('canvas');
const context = textCanvas.getContext('2d');

textCanvas.width = 512; // Adjust as needed
textCanvas.height = 512; // Adjust as needed

var poemText = `The critical thought
Is to say
Of course, you
Sashayed comme un
Ange through white
Horizon, mountains of
Sea, suckle eye
Milky Way as
It be when
 
Guide of map
Omega. But I
Know better. Couldn’t
Say in modern
Ity. Pneuma Sophia
Post immediate eternal
Aiōn aisthētikos Fluid
Base blank full
With rhythms of
The sea. [I’ve

Braided my hair
Nonchalantly. Brands disturb
Harmony and today’s
Symbols have lost
Their symphony. I
Wish you were
here. Her name,
Saudade. Spark. Touch
 
Your skin with
Clean eyes ritual
fuck frontal lobe
stark symbol of
the yearning art
Mottled viscous bruise
of its own
Implicit breathe there
Must be a

Trilogy.  Dance Caress
Entrance. The rhyme.
We say. Nothing.
Of after. Birds.
Sun. Curtains. Lashes.
Navel. Shadow. Nous.
I am here
For the Revelation:
Trinity * Trinity]
 
You reveal doom
The devil enters
Sweet desire, sweet
Black hole, I
Repent, drip, rage
Unworthy, unholy, whore
John, why such
Blasphemy? Peter, why
Sin’s incessant jeer

Paul, superlative smite
I want to
Give; you ask
STOP 	  ask	STOP
Slaughter peacock What
else? Arrheton echo
You will not
Stop until the
Kingdom is yours.
 
A triangle stands
Alone. Pinnacle of
Spirit, matter, Lord
It is time
to cube the
equation time to
twin the soul
Power of Three
Three. Three to

the power. Beyond
Euclid’s plane a
Star multiplies: us
We are two
Triangles meeting at
A star. A
Third invisible. Felt. 
Wordless divine guiltless
The star does
 
not ask; Is
Body word soul
Unite kiss breathe
Not with desire
But devotion. Gratitude
Infinite space to
Swell, to fill,
To condense into
Air, into vapor,

Horizon. To calm,
To Inspire. The
Sea. Asks nothing.
(Be) The star,
The Kiss, the
Union. Trinity field
Of two triangles
Meeting at a
Prayer, are us.
 
The wretched weep
But we are
The wretched. Beings
Inevitably foul (swell)
Genesis Babel Flood
Perfection impossible, cheap
And I grieve
Pray to perfection
eidos teleiotes idea

Sweet mirror X
Sensation of peace
Uninterrupted by decision
Uninterrupted by desire
Uninterrupted by storm
And I wail
That the good
Should be the
Enemy (condense) of
 
The perfect. Rage
That we must
Call it sin
To realize the
Weight of guilt
No tears may
Bear they are
Too sweet. A
Word struggles to

Emerge. Can’t. Black.
Descend into the
Pain of knowing
Your presence ___
Be no gift.
Come back from
The void (the
Perfect) She bids
Because sun doesn’t
 
Give a damn
If you are
Albino or Hitler
Or even Einstein
Sun, hapless sun
Glorious prime mover
Deity of trinity
Star moon earth
Khaos Cosmos Universe

Uneven garnish of
light on this
 page. Simple sea. 
Miracle being. Birth
of tomatoes. Fleshy
Olives. Goosebumps. Shade.
Sinew. Sandals. Color.
Saliva. Gift of
Breathe, of joy
 
And love. Life!
O! such gratitude
Knelt in abandon
Complete Zero Gravity
Still air hovering
Merciful over horizon
Total.  Monk chanting
Solitude. To exist
On barren lava

Peaks: a goat
The edge of
The earth a
Voice – you’re alive
Stone. Dust. Dialectos.
Element: Energy - Kneel
Without choice abandon
Knowing. Alive. Quake
at the horizon.
 
White line infinite
I’ve evaporated into
The thing itself
No distance. One
edge of sea
and sky. Engulf.
Surrender. Sense. Feed.
Sun Sea Earth 
Irreducible forms, the.

Our wobegone logos
Hard thoughts at
Each others’, no --
I swell body
word soul gaping
stitches seamless love
 is faith: bare
immaculate (I am)
But for gratitude:
 
If you are
The moon it
Is time you
Set and wane
And wander but
Never so much
As Venus or
Mars (and today
And then again,

You come) When
I call when
I breathe your
Name rhythm of
Sea: my head
You always come
There is no
End to the
Power of three
 
Infinity three. What
Can contain the
Coast or sea?
Galaxias, find the
Point exact: Behind,
After Zeno? Nevermind
Horizon where do
 You lie? The
Mind. No. Heart.

The moon’s intuition
Breathes late August
Blue moon drunk
With love for
Hera I have
Known other types
of ecstasy but
None as pure
As Heroine none
 
As pure as
Trinity Star Trinity
give with abandon
feel only adoration
the more I
sense your energy
the higher it
multiplies love is
the source to

infinity, three. Here!
Now! God the
Belief in infinity
Damnation of totality
Trinity Star Trinity
I believe in
Infinity I believe
We are one
Trinity. Star. Trinity.`;


    </script>

</head>
<body>

    <div id="app">
        <div id="thresholds">
          <div class="file-input-group">
            <label for="audioInput">Music:</label>
            <input type="file" id="audioInput" multiple accept="audio/*, .midi, .mid" />
          </div>
          <div class="file-input-group">
            <label for="videoInput">Video:</label>
            <input type="file" id="videoInput" accept="video/*" multiple />
          </div>
          <input type="file" id="xmlInput" accept=".xml" />
          
          <pre id="output"></pre>
        
          <button id="startButton">Start</button>
          <button id="orbButton" onclick="renderTrinityOrb(5)">Trinity</button>
          <button id="poemButton" onclick="processPoemText(poemText)">Poem</button>

          <button id="poemTextButton" onclick="startTextAnimation(100)">Text</button>

         

          <label for="speedRange">Adjust Speed:</label>
          <input type="range" id="speedRange" min="50" max="1000" value="200">
          
          <button id="beatButton" onclick="hide()">Hide ("h")</button>

          <video id="videoElement" class="hidden" autoplay muted></video>
          
          <div id="master-control">
             <input type="range" id="volumeSlider" min="0" max="1" step="0.01" value="1" >

            <label for="master">Equalizer Master Volume :</label>
            <input type="range" id="master" min="-100" max="355" value="150" />
          </div>
        </div>

        <!-- <div id="advancedControls"></div> -->
      </div>
      <div id="videoList">"v" to toggle view
        <div id="videoListContents"></div>
      </div>

      <div id="container"></div>
      
<script>

        let activeOffset = 1;
        let colorShaderMode = false;
        let hueoffset = 20;
        let hueoffset1 = 20;
        let hueoffset2 = 20;
        let hueoffset3 = 20;
        let hueoffset4 = 20;
        let hueoffset5 = 20;
        let hueOffsetSpeed = 0;
        let mixedModeCounter = 0;
        let startingVolumeThreshold = 5;
        let freezeFrameEffectActive = true;
        let X_ROTATION_SPEED = 0;
        let Y_ROTATION_SPEED = 0;
        let activegeometriesopacityreduction = 0.01;
        let activegeometriesagedeath = 10;
        let ACTIVE_GEOMETRIES_LIMIT = 7;
        let FORCE_EQUILATERAL = false;
        let innerTriangleActive = false;
        let innerTriangleOffset = 0.005;
        let merkabaMode = false;
        let noteDisplayEnabled= false;
        let peakBandIndex;
        let playbackRate= 1.0;
        let videoFullOpacity = true;
        let videoTexture;
        let REFRESH_SPEED = 3;
        let saturation = 100;
        let brightness = 50; 
        let volumemagnification = 1.4; 

        let captureInterval;
        const CAPTURE_INTERVAL_MS = 416.666666667 / 2;  // e.g., Capture every Xms 

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 100);
        camera.position.z = 2;
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio * 5); // x times the normal resolution

        renderer.shadowMap.enabled = true;
        const pointLight = new THREE.PointLight(0xffffff, 1, 100);
        pointLight.position.set(1, 1, 1);  // x, y, z
        scene.add(pointLight);
        pointLight.castShadow = true;


        let container = document.getElementById('container');

        //TODO: might want to revisit this and reset it if the window sie has
        renderer.setSize(container.clientWidth, container.clientHeight);
        container.appendChild(renderer.domElement);

        var analyser;

        let numBands = 48;
        let thresholds = Array(numBands).fill(startingVolumeThreshold);

        let holographicFanMode = false;

        let baseFrequency = 20; // Start from 20 Hz
        let maxFrequency = 20000; // Up to 20 kHz
        let MAX_SIZE;
        let dodecahedronMaterial; 

                // Now calculate the ratio between each band in a logarithmic scale
        let ratio = Math.pow(maxFrequency / baseFrequency, 1.0 / (numBands - 1));
       
       
        let points = [];
        let lines = [];
        let geometries = [];
        let lastPoints = [];

        //TODO: this function doesn't preoperly work when run repeat times (i.e. the points are evenly distributed over the surface of the sphere)
        function initBands(){

        // Now we can get the frequency for each band
        for (let i = 0; i < numBands; i++) {
        let bandFrequency = baseFrequency * Math.pow(ratio, i);
        console.log('Band ' + i + ' frequency: ' + bandFrequency + ' Hz');
        }

        

        let goldenRatio = (1 + Math.sqrt(5)) / 2;
        let angleIncrement = Math.PI * 2 * goldenRatio;


            for (let i = 0; i < numBands; i++) {
                let v = i / numBands;
                let phi = v * Math.PI;
                let theta = angleIncrement * i;

                let x = Math.sin(phi) * Math.cos(theta);
                let y = Math.sin(phi) * Math.sin(theta);
                let z = Math.cos(phi);

                x = isNaN(x) ? 0 : x;
                y = isNaN(y) ? 0 : y;
                z = isNaN(z) ? 0 : z;

                let point = new THREE.Points(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0)]), new THREE.PointsMaterial({color: 0xffffff, size: 0.01}));
                point.position.set(x, y, z);
                points.push(point);
                // scene.add(point);


            }


        }

        initBands();
        let lineCount = 0;

        function updateTextCanvas(text, fontSize = 48) {
            context.clearRect(0, 0, textCanvas.width, textCanvas.height); // Clear the canvas
            context.font = `${fontSize}px Arial`;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, textCanvas.width / 2, textCanvas.height / 2);
        }

        updateTextCanvas('');

        // Create a texture from the canvas
        const texture = new THREE.Texture(textCanvas);
        texture.needsUpdate = true;

        // Create a material using this texture
        const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: true });

        // Create a plane geometry for the text
        const geometry = new THREE.PlaneGeometry(5, 5); // Adjust size as needed

        const textMesh = new THREE.Mesh(geometry, material);

        // Add the text mesh to your scene
        scene.add(textMesh);


        function displayNextCharacter() {
            console.log("dnc");

            if (currentIndex < poemText.length) {
                currentText += poemText.charAt(currentIndex);
                console.log(currentText);
                updateTextCanvas(currentText); // Update the canvas with the new text
                texture.needsUpdate = true; // Important to refresh the texture
                currentIndex++;
            } else {
                clearInterval(intervalHandle);
                intervalHandle = null;
            }
        }

        function displayNextCharacter() {
            if (currentIndex < poemText.length) {
                const char = poemText.charAt(currentIndex);
                currentText += char;
                updateTextCanvas(currentText);
                texture.needsUpdate = true;
                currentIndex++;

                if (char === '\n') lineCount++;
                if (lineCount === 3) { // Every three lines
                    lineCount = 0;
                    textMesh.rotation.z += Math.PI / 3; // Rotate by 60 degrees
                }
            } else {
                clearInterval(intervalHandle);
                intervalHandle = null;
            }
        }

        function startTextAnimation(speed) {
            if (intervalHandle) clearInterval(intervalHandle);
            displaySpeed = speed;
            console.log("sta");
            intervalHandle = setInterval(displayNextCharacter, displaySpeed);
        }


        const colorIsolationShader = {
    uniforms: {
        uTexture: { value: videoTexture },
        targetColor: { value: new THREE.Vector3(1.0, 0.0, 0.0) }, // Example: target red
        tolerance: { value: 1.4 }, // Adjust for stricter or looser color matching
        opacityLevel: { value: 1.0 } // Default opacity
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: `
        precision highp float;
        varying vec2 vUv;
        uniform sampler2D uTexture;
        uniform vec3 targetColor;
        uniform float tolerance;
        uniform float opacityLevel;

        void main() {
            vec4 texColor = texture2D(uTexture, vUv);
            float colorDistance = distance(targetColor, texColor.rgb);
            if (colorDistance < tolerance) {
                gl_FragColor = vec4(texColor.rgb, opacityLevel);
            } else {
                gl_FragColor = vec4(1.0, 0.0, 0.0, opacityLevel); // Red for colors outside the tolerance
            }
        }
    `
};

        const volumeSlider = document.getElementById('volumeSlider');
        volumeSlider.addEventListener('input', function() {
            const volume = this.value;
            // audioSource.setVolume(volume);
            var gainNode = audioContext.createGain()
            gainNode.gain.value = parseInt(volume) / 100 // 0.1 // 10 %
            gainNode.connect(audioContext);

        });

        function captureAudioData() {


            let data = new Uint8Array(analyser.frequencyBinCount);
            analyser.getByteFrequencyData(data);

            let bandSize = Math.floor(data.length / numBands);

            clearNoteSpheres();

            let bandWidth = audioContext.sampleRate / analyser.frequencyBinCount; // Adjust as necessary based on how you set up the Web Audio API.
           
            // console.log(bandWidth);

            let peakVolume = 0;
            let peakBand = null;
            // console.log(numBands);
            for (let i = 0; i < numBands; i++) {
                // console.log("i");

                let band = data.slice(i * bandSize, (i + 1) * bandSize);
                let volume = getAverageVolume(band);
                
                if (volume > peakVolume) {
                    peakVolume = volume;
                    peakBand = band;
                    peakBandIndex = i;  // Store the index of the peak band
                    // console.log("peakBandIndex" + peakBandIndex);

                }
            }
            // console.log("Peak band index:", peakBandIndex);
            // console.log("Peak volume:", peakVolume);


            if (peakBand && false) {

                analyser.getFloatTimeDomainData( buf );
                var ac = autoCorrelate( buf, audioContext.sampleRate );
                pitch = ac;
                var note =  noteFromPitch( pitch );
                // // console.log(note);
                // // var otherNote = detectNoteFromBand(peakBand, bandWidth);
                // // console.log("Detected note for peak band:", note);

                if (note && noteDisplayEnabled) {
                    console.log("Peak note detected");
                    console.log(peakBandIndex);
                    let noteText = noteStrings[note%12];
                    console.log(noteText);
                    let noteSphere = createNoteSphere(noteText);
                    noteSphere.position.copy(points[peakBandIndex].position);
                    noteSphere.userData.type = 'noteSphere';  // Tagging the sphere so that we can easily remove it later
                    noteSphere.scale.set(0.1, 0.1, 0.1);  // Scale down the sphere to make it smaller
                    noteSphere.rotation.y = -Math.PI / 2;
                    scene.add(noteSphere);
                    // console.log("Added peak note sphere:", noteSphere);
                }
            }


            for (let i = 0; i < numBands; i++) {
                // TODO: this doesn't seem to be properly using the band frequency

                let band = data.slice(i * bandSize, (i + 1) * bandSize);
                let volume = getAverageVolume(band);
                let volumeDisplay = document.getElementById('volume' + i);
                volumeDisplay.textContent = ' ' + volume.toFixed(2) + ' / ' + thresholds[i];


                if (volume >= thresholds[i]) {


                    // TODO pull from active color range
                    // increment, move to next range

                    if(activeOffset > 5)
                        activeOffset = 1; 

                    let activeHueoffset = 20;
                    if (activeOffset == 1)
                        activeHueoffset = hueoffset1;
                    if (activeOffset == 2)
                        activeHueoffset = hueoffset2;
                    if (activeOffset == 3)
                        activeHueoffset = hueoffset3;
                    if (activeOffset == 4)
                        activeHueoffset = hueoffset4;
                    if (activeOffset == 5)
                        activeHueoffset = hueoffset5;
                    console.log(activeHueoffset);
                    let hue = (volume * volumemagnification) + activeHueoffset;
                    activeOffset++; 


                    // let hue = 10;
                    if (hue > 360) hue -= 360;
                    let color = new THREE.Color('hsl(' + hue + ', ' + saturation + '%, ' + brightness  + '%)');
                    updateTargetColor(color);




                    // console.log(band);


                    // let detectedNote = detectNote(band);  // Implement detectNote() based on your frequency to note logic
                    // if (detectedNote) {

                    // }

                    if(points[i]) points[i].material.color = color;

                    volumeDisplay.style.color = '#00ff00'; // green
                    if (lastPoints.length >= 3) {


                        var geometry = createTriangleGeometry(lastPoints[0], lastPoints[1], lastPoints[2]);
                        var material; 
                        if(mixedElementActive)
                            mixedModeCounter++;

                        if(videoElementActive && (mixedModeCounter % 2 == 0 )) {
                            videoTexture = getVideoFrameTexture();
                             let opacitylevel=1;
                             if (videoFullOpacity)
                                opacitylevel = 1;
                            else
                               opacitylevel =  (12 / volume ) + .2;
                             // TODO: hits infinity too often
                            //  console.log(opacitylevel);
                            if (colorShaderMode) {
                                material = new THREE.ShaderMaterial(colorIsolationShader);

                            } else {
                                material = new THREE.MeshBasicMaterial({map:videoTexture, opacity: opacitylevel, transparent: true, side: THREE.DoubleSide});

                            }
                             material.needsUpdate = true;
                        }
                        else if (imageElementActive) {

                            videoTexture = getNextImageTexture();
                             material = new THREE.MeshBasicMaterial({map:videoTexture, opacity: 0.6, transparent: true, side: THREE.DoubleSide});
                             material.needsUpdate = true;

                        } else  {

                            material = new THREE.MeshBasicMaterial({color: color, opacity: 0.6, transparent: true, side: THREE.DoubleSide});

                        }

                        var triangle = new THREE.Mesh(geometry, material);

                
                        triangle.castShadow = true;    // to cast shadows
                        triangle.receiveShadow = true; // to receive shadows

                        // const tetra = new THREE.TetrahedronGeometry(.5);


                        scene.add(triangle); 
                        if (innerTriangleActive)
                        {
                            var innerGeometry = createInnerTriangleGeometry(lastPoints[0], lastPoints[1], lastPoints[2]);
                            var innerMaterial = new THREE.MeshBasicMaterial({color: "black", opacity: 0.5, transparent: false, side: THREE.DoubleSide});
                            var innerTriangle = new THREE.Mesh(innerGeometry, innerMaterial);
                            scene.add(innerTriangle); 

                        }

                        if (geometries.length > ACTIVE_GEOMETRIES_LIMIT) {

                                geometries[0].geometry.geometry.dispose();
                                geometries[0].geometry.material.dispose();
                                scene.remove(geometries[0].geometry);
                                geometries.shift();

                        }

                        geometries.push({geometry: triangle, age: 0});
                        if (innerTriangleActive)
                        {
                            geometries.push({geometry: innerTriangle, age: 0});

                        }

                        lastPoints.shift();
                    }

                    lastPoints.push(points[i].position.clone());
                } else {
                    volumeDisplay.style.color = '#ff0000'; // red
                }
            }

            for (let i = geometries.length - 1; i >= 0; i--) {
                geometries[i].age++;
                if (geometries[i].age > activegeometriesagedeath) {
                    geometries[i].geometry.material.opacity -= activegeometriesopacityreduction;
                    geometries[i].geometry.material.opacity -= activegeometriesopacityreduction;
                    if (geometries[i].geometry.material.opacity <= 0) {
                        scene.remove(geometries[i].geometry);
                        geometries.splice(i, 1);
                    }
                }
            }
        }

        function updateTargetColor(updatedColor) {
            colorIsolationShader.uniforms.targetColor.value.set(updatedColor.r, updatedColor.g, updatedColor.b);
        }

        function animate() {
            requestAnimationFrame(animate);

            // untoggle if to make fully deterministic
            hueoffset += hueOffsetSpeed;

            if(hueoffset > 360) {
                hueoffset -= 360;
            }



            scene.rotation.x += X_ROTATION_SPEED; 
            scene.rotation.y += Y_ROTATION_SPEED;

            renderer.render(scene, camera);
        }

        let previousEnergies = []; // To store recent energy values
        let ENERGY_HISTORY = 10;  // How many past energy values to store
        let BEAT_THRESHOLD = 1.05; // To be adjusted
        let beatDataArray;
        let bufferLength;

        let audioContext;
        let biquadFilter;
        let startButton = document.getElementById('startButton');
        startButton.addEventListener('click', function() {
            startButton.parentElement.removeChild(startButton);

            navigator.mediaDevices.getUserMedia({ video: false, audio: true}).then(function(stream) {

            //NOTE: this helped with some pitch detection but had side effects

            // navigator.mediaDevices.getUserMedia({ video: false, audio: {
            // "mandatory": {
            //     "googEchoCancellation": "false",
            //     "googAutoGainControl": "false",
            //     "googNoiseSuppression": "false",
            //     "googHighpassFilter": "false"
            // }}}).then(function(stream) {
                
                audioContext = new AudioContext();
                let source = audioContext.createMediaStreamSource(stream);
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 2048 * 2;
                source.connect(analyser);

                //NOTE: not sure this is adding much value

                biquadFilter = audioContext.createBiquadFilter();
                biquadFilter.type = "lowpass";
                biquadFilter.frequency.setValueAtTime(150, audioContext.currentTime); // Keeping frequencies below 150Hz
                source.connect(biquadFilter);
                biquadFilter.connect(analyser);
                
                bufferLength = analyser.frequencyBinCount;
                beatDataArray = new Uint8Array(bufferLength);
                animate();
                captureInterval = setInterval(captureAudioData, CAPTURE_INTERVAL_MS);
                MAX_SIZE = Math.max(4,Math.floor(audioContext.sampleRate/5000));	// corresponds to a 5kHz signal
                // startPitchDetect();
                // updatePitch();

            });
        });


        
        let masterInput = document.getElementById('master');
        masterInput.value = startingVolumeThreshold;

        let thresholdsDiv = document.getElementById('thresholds');
        let startingVolumeThresholds = new Array(numBands).fill(startingVolumeThreshold);

        for(let i = 0; i < numBands; i++){
            let highEnd = 200; // maximum volume threshold for lowest frequency band
            let lowEnd = 10;   // minimum volume threshold for highest frequency band
            let range = highEnd - lowEnd;

            let input = document.createElement('input');
            input.type = 'range';
            input.min = '0';
            input.max = '255';
            input.value = startingVolumeThreshold;
            startingVolumeThresholds[i] = startingVolumeThreshold;
            thresholds[i] =  startingVolumeThreshold;

            // input.value = highEnd - Math.floor((i/numBands) * range);
            // startingVolumeThresholds[i] = highEnd - Math.floor((i/numBands) * range);
            input.id = 'threshold' + i;
            input.oninput = function(){
                thresholds[i] = this.value;  // Set the threshold for specific band
                // Add this line to update the display text when the threshold changesf
                // document.getElementById('volume' + i).textContent = 'v: ' + startingVolumeThresholds[i] + ' 0 / ' + startingVolumeThresholds[i];
                document.getElementById('volume' + i).textContent = ' 0 / ' + thresholds[i];

            };

            let volumeDisplay = document.createElement('span');
            volumeDisplay.id = 'volume' + i;
            volumeDisplay.style.color = 'white';
            volumeDisplay.textContent = "v: ";

            thresholdsDiv.appendChild(document.createTextNode('Band ' + i + ': '));
            thresholdsDiv.appendChild(input);
            thresholdsDiv.appendChild(volumeDisplay);
            thresholdsDiv.appendChild(document.createElement('br'));
            document.getElementById('volume' + i).textContent = 'v: 0 / ' + thresholds[i];
            document.getElementById('volume' + i).style = 'color:black';

        }

        let master = document.getElementById('master');
        let lastMasterValue = startingVolumeThreshold;
        master.oninput = function() {
            let masterValue = this.value;
            let delta = masterValue - lastMasterValue;
            // startingVolumeThresholds = startingVolumeThresholds.map(() => masterValue);  // Set all thresholds to the master's value

            for (let i = 0; i < numBands; i++) {
                let input = document.getElementById('threshold' + i);
                thresholds[i] =  parseInt(input.value) + delta;
                input.value = parseInt(input.value) + delta;
                document.getElementById('volume' + i).textContent = 'v: 0 / ' + input.value;
            }

            lastMasterValue = masterValue;
        };

        const audioQueue = [];
        let audioSource;  // Keep track of the current audio source

    document.getElementById('audioInput').addEventListener('change', async function(event) {

        audioContext = new AudioContext();
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 2048 * 2 * 2;

        // Populate the audioQueue with the selected files
        audioQueue.length = 0;  // Clear the queue
        for (let file of event.target.files) {
            console.log(file);
            audioQueue.push(file);
        }

        playNext();

    });


    // XML color range extraction
    document.getElementById('xmlInput').addEventListener('change', function(e) {
      const file = e.target.files[0];
      const reader = new FileReader();

      reader.onload = function(e) {
        const xmlContent = e.target.result;
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(xmlContent, 'text/xml');

        const colorChoices = xmlDoc.getElementsByTagName('Choice');
        const colorRanges = [];

        for (let i = 0; i < colorChoices.length; i++) {
          const colorChoice = colorChoices[i];
          const colorName = colorChoice.getAttribute('name');
          const colorValue = colorChoice.getAttribute('value');

          colorRanges.push(`${colorName}: ${colorValue}`);
        }

        document.getElementById('output').textContent = colorRanges.join('\n');
        console.log(colorRanges);
      };

      reader.readAsText(file);
    });



    // function playSound(buffer) {
    //     let source = audioContext.createBufferSource(); 
    //     source.buffer = buffer;
    //     source.connect(analyser); // Connect source to the analyser
    //     source.connect(audioContext.destination); // Connect source to the speakers
    //     source.start(0);
    // }

// SECTION: video

        // for video render


    function readPoem() {


        
    }

    function setupPoemScene(linesGroup) {
    // Setup the Three.js scene
    // const scene = new THREE.Scene();
    // const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    // camera.position.z = 5;

    // const renderer = new THREE.WebGLRenderer();
    // renderer.setSize(window.innerWidth, window.innerHeight);
    // document.body.appendChild(renderer.domElement);

    // Create a group to hold the triangles
    const trianglesGroup = new THREE.Group();

    // Define geometry for the triangles
    const triangleGeometry = new THREE.Geometry();
    triangleGeometry.vertices.push(
        new THREE.Vector3(-1, 0, 0), // Vertex 1
        new THREE.Vector3(1, 0, 0),  // Vertex 2
        new THREE.Vector3(0, Math.sqrt(3), 0) // Vertex 3
    );
    triangleGeometry.faces.push(new THREE.Face3(0, 1, 2));

    // Create three triangles and position them
    for (let i = 0; i < 3; i++) {
        const triangleMesh = new THREE.Mesh(triangleGeometry, new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true }));
        triangleMesh.rotation.z = (Math.PI * 2 / 3) * i; // Rotate each triangle
        trianglesGroup.add(triangleMesh);
    }

    // Create text geometry for each line and position them on the vertices
    const loader = new THREE.FontLoader();

    // Ensure you have the font data available (e.g., from a JSON file or inline variable)
    loader.load('path_to_font.json', function (font) {
        linesGroup.forEach((lines, index) => {
            lines.forEach((line, vertex) => {
                const textGeometry = new THREE.TextGeometry(line, {
                    font: font,
                    size: 0.2,
                    height: 0.01
                });

                // Position the text on the vertices
                const textMesh = new THREE.Mesh(textGeometry, new THREE.MeshBasicMaterial({ color: 0x000000 }));
                textMesh.position.copy(trianglesGroup.children[index].geometry.vertices[vertex]);
                scene.add(textMesh);
            });
        });
    });

    // Add the triangles group to the scene
    scene.add(trianglesGroup);

}


function readPoemAndDisplay(url) {
    url = "trinitypoem.txt";
    fetch(url)
        .then(response => response.text())
        .then(text => {
            const lines = text.split('\n').filter(line => line.trim() !== ''); // Split by new line and remove blank lines
            const linesGroup = [];

            // Group lines into sets of nine, skipping blank lines
            for (let i = 0, group = []; i < lines.length; i++) {
                if (lines[i].trim() !== '') {
                    group.push(lines[i]);
                    if (group.length === 9) {
                        linesGroup.push(group);
                        group = [];
                    }
                }
            }

            // If the last group has less than 9 lines, you can decide to add it or not
            if (group.length > 0 && group.length < 9) {
                linesGroup.push(group); // Add the last group even if it's incomplete
            }

            // Pass the grouped lines to the setup function
            setupPoemScene(linesGroup);
        })
        .catch(error => console.error('Error fetching the poem:', error));
}

let group = [];

function processPoemText(poemText) {
            const lines = poemText.split('\n').filter(line => line.trim() !== ''); // Split by new line and remove blank lines
            const linesGroup = [];

            // Group lines into sets of nine, skipping blank lines
            for (let i = 0; i < lines.length; i++) {
                console.log("n");
                group.push(lines[i]);
                if (group.length === 9) {
                    linesGroup.push(group);
                    group = [];
                }
            }
            

            // If the last group has less than 9 lines, you can decide to add it or not
            // if (group.length > 0 && group.length < 9) {
            //     linesGroup.push(group); // Add the last group even if it's incomplete
            // }

            // Pass the grouped lines to the setup function
            setupPoemScene(linesGroup);
        }

document.getElementById('speedRange').addEventListener('input', function() {
    const newSpeed = parseInt(this.value, 10);
    startTextAnimation(newSpeed);
});

// claude3 also sucks
function renderTrinityOrb(sizeFactor) {

    // Create a circular geometry
    const radius = 2;
    const segments = 64;
    const circleGeometry = new THREE.CircleGeometry(radius, segments);

    // Create a material for the circle
    const circleMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });

    // Create a LineSegments object for the circle
    const circle = new THREE.LineSegments(new THREE.EdgesGeometry(circleGeometry), circleMaterial);
    scene.add(circle);

    // Create line geometries for the intersecting lines
    const lineGeometry1 = new THREE.BufferGeometry().setFromPoints([
    new THREE.Vector3(-radius, 0, 0),
    new THREE.Vector3(radius, 0, 0)
    ]);

    const lineGeometry2 = new THREE.BufferGeometry().setFromPoints([
    new THREE.Vector3(0, -radius, 0),
    new THREE.Vector3(0, radius, 0)
    ]);

    // Create a material for the lines
    const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });

    // Create Line objects for the intersecting lines
    const line1 = new THREE.Line(lineGeometry1, lineMaterial);
    const line2 = new THREE.Line(lineGeometry2, lineMaterial);
    scene.add(line1, line2);

    }
    // GPT sucks
    function renderTrinityOrbbyChatGPT2(sizeFactor) {





    // Create quarter-circle
    const quarterCircleRadius = 2 / sizeFactor;
    const curve = new THREE.EllipseCurve(
        0, 0,             // ax, aY
        quarterCircleRadius, quarterCircleRadius, // xRadius, yRadius
        0, Math.PI / 2,   // aStartAngle, aEndAngle
        false,            // aClockwise
        0                 // aRotation
    );

    const points = curve.getPoints(50);
    const geometry = new THREE.BufferGeometry().setFromPoints(points);

    const material = new THREE.LineBasicMaterial({ color: 0xffffff });
    const quarterCircle = new THREE.Line(geometry, material);

    // Create the lines
    const lineGeometry = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(-quarterCircleRadius, 0, 0),
        new THREE.Vector3(0, quarterCircleRadius, 0)
    ]);
    const line = new THREE.Line(lineGeometry, material);

    // Add the quarter-circle and line to the scene
    scene.add(quarterCircle);
    scene.add(line);

    // Now clone and mirror the quarter-circle and line across the X and Y axes to complete the pattern
    const quarterCircleMirrorX = quarterCircle.clone();
    quarterCircleMirrorX.rotation.z = Math.PI;
    scene.add(quarterCircleMirrorX);

    const quarterCircleMirrorY = quarterCircle.clone();
    quarterCircleMirrorY.rotation.z = -Math.PI / 2;
    scene.add(quarterCircleMirrorY);

    const lineMirrorX = line.clone();
    lineMirrorX.rotation.z = Math.PI;
    scene.add(lineMirrorX);

    const lineMirrorY = line.clone();
    lineMirrorY.rotation.z = -Math.PI / 2;
    scene.add(lineMirrorY);



    }


    function hide() {
        document.getElementById("thresholds").style.display = "none";
    }


    </script>
<script src="js/video_processor.js"></script>
<script src="js/pitchdetect.js"></script>
<script src="js/note_analyzer.js"></script>
<script src="js/audio_controller.js"></script>
<script src="js/sonic_geometries.js"></script>
<script src="js/message_controller.js"></script>
</body>
</html>
